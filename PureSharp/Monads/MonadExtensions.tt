<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using PureSharp.MayBeMonad2;
using PureSharp.MayBeMonad;

<#
const string rootNameSpace = "PureSharp";
Generate(rootNameSpace, "LazyMonad", "LazyExtensions", x => string.Format("Lazy<{0}>", x), false);
Generate(rootNameSpace, "MayBeMonad", "MayBeExtensions", x => x, true);
Generate(rootNameSpace, "MayBeMonad2", "MayBe2Extensions", x => string.Format("MayBe<{0}>", x), true);
Generate(rootNameSpace, "ReaderMonad", "ReaderExtensions", x => string.Format("Func<E, {0}>", x), false, "E, ");
Generate(rootNameSpace, "WriterMonad", "WriterExtensions", x => string.Format("Writer<W, {0}>", x), false, "W, ", "source.Monoid");

GenerateMayBeT2("Lazy");
Generate(rootNameSpace, "LazyMayBeMonad2", "LazyMayBe2Extensions", x => string.Format("LazyMayBe<{0}>", x), true);

GenerateMayBeT("Lazy");
Generate(rootNameSpace, "LazyMayBeMonad", "LazyMayBeExtensions", x => string.Format("LazyMayBe<{0}>", x), true);
#>

<#+void Generate(string rootNameSpace, string nameSpace, string className, Func<string, string> monadName, bool hasEmpty, string addidional = "", string unitParam = "") {#>
namespace <#=rootNameSpace#>.<#=nameSpace#> {
    partial class <#=className#> {
        public static <#=monadName("C")#> SelectMany<<#=addidional#>A, B, C>(this <#=monadName("A")#> source, Func<A, <#=monadName("B")#>> f, Func<A, B, C> resultSelector) {
            return source.SelectMany(
                outer => f(outer).SelectMany(
                inner => resultSelector(outer, inner).Unit<<#=addidional#>C>(<#=unitParam#>)));
        }
        public static <#=monadName("B")#> Select<<#=addidional#>A, B>(this <#=monadName("A")#> source, Func<A, B> f) {
            return source.SelectMany(x => f(x).Unit<<#=addidional#>B>(<#=unitParam#>));
        }
<#+if(hasEmpty) {#>
        public static <#=monadName("A")#> Where<<#=addidional#>A>(this <#=monadName("A")#> source, Func<A, bool> f) {
            return source.SelectMany(x => f(x) ? x.Unit<<#=addidional#>A>(<#=unitParam#>) : Empty<A>());
        }
<#+}#>
    }
}
<#+}#>

<#+void GenerateMayBeT2(string monadName) {
    string containerName = monadName + "MayBe";
    string extensionClassName = monadName + "Monad." + monadName + "Extensions";
#>
namespace PureSharp.<#=monadName#>MayBeMonad2 {
    public static partial class <#=monadName#>MayBe2Extensions {
        static <#=containerName#><A> Unit<A>(this A source) {
            return <#=extensionClassName#>.Unit(source.AsMayBe()).As<#=containerName#>();
        }
        static <#=containerName#><A> Empty<A>() {
            return <#=extensionClassName#>.Unit(MayBe2Extensions.Empty<A>()).As<#=containerName#>();
        }
        static <#=containerName#><B> SelectMany<A, B>(this <#=containerName#><A> source, Func<A, <#=containerName#><B>> f) {
            return <#=extensionClassName#>.SelectMany<MayBe<A>, MayBe<B>>(
                source.Value,
                x => (x.Value != null ? f(x.Value).Value : <#=extensionClassName#>.Unit(MayBe2Extensions.Empty<B>()))
            ).As<#=containerName#>();
        }
    }
}
<#+}#>
<#+void GenerateMayBeT(string monadName) {
    string containerName = monadName + "MayBe";
    string extensionClassName = monadName + "Monad." + monadName + "Extensions";
#>
namespace PureSharp.<#=monadName#>MayBeMonad {
    public static partial class <#=monadName#>MayBeExtensions {
        static <#=containerName#><A> Unit<A>(this A source) {
            return <#=extensionClassName#>.Unit(source).As<#=containerName#>();
        }
        static <#=containerName#><A> Empty<A>() {
            return <#=extensionClassName#>.Unit(MayBeExtensions.Empty<A>()).As<#=containerName#>();
        }
        static <#=containerName#><B> SelectMany<A, B>(this <#=containerName#><A> source, Func<A, <#=containerName#><B>> f) {
            return <#=extensionClassName#>.SelectMany<A, B>(
                source.Value,
                x => (x != null ? f(x).Value : <#=extensionClassName#>.Unit(MayBeExtensions.Empty<B>()))
            ).As<#=containerName#>();
        }
    }
}
<#+}#>